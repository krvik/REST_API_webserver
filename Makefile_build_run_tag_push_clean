APP_NAME = rest_api_app
VERSION ?= 1.0.0
REGISTRY = docker.io/vikashkumardev1996


#-------Config--------
DB_IMAGE        := postgres:15
DB_CONTAINER    := rest_api_db
DB_NAME         := students_db
DB_USER         := postgres
DB_PASSWORD     := postgres
DB_PORT         := 5432
DB_HOST         := $(DB_CONTAINER)
DB_VOLUME       := pgdata_rest
DB_NETWORK      := rest_net


# SQL files (optional – only if you have them)
SCHEMA_SQL := db/schema.sql
DML_SQL    := db/dml.sql


# Connection strings
DATABASE_URL := postgresql://$(DB_USER):$(DB_PASSWORD)@$(DB_HOST):$(DB_PORT)/$(DB_NAME)


# Helpers
.PHONY: up down build api-run api-stop db-start db-wait db-shell db-stop db-reset migrate hel


# =========================
# 1) Build the API image
# =========================
build:
	@echo "==> Building API image $(APP_NAME):$(VERSION)"
	docker build -t $(APP_NAME):$(VERSION) .

# =========================
# 2) Start PostgreSQL DB
# =========================

db-start:
	@echo "==> Creating network (if missing): $(DB_NETWORK)"
	@docker network inspect $(DB_NETWORK) >/dev/null 2>&1 || docker network create $(DB_NETWORK)
	@echo "==> Creating volume (if missing): $(DB_VOLUME)"
	@docker volume inspect $(DB_VOLUME) >/dev/null 2>&1 || docker volume create $(DB_VOLUME)
	@echo "==> Starting Postgres container: $(DB_CONTAINER)"
	@docker ps --format '{{.Names}}' | grep -q '^$(DB_CONTAINER)$$' || \
	docker run -d --name $(DB_CONTAINER) \
		--network $(DB_NETWORK) \
      		-e POSTGRES_USER=$(DB_USER) \
      		-e POSTGRES_PASSWORD=$(DB_PASSWORD) \
      		-e POSTGRES_DB=$(DB_NAME) \
		-p $(DB_PORT):5432 \
      		-v $(DB_VOLUME):/var/lib/postgresql/data \
      		$(DB_IMAGE)


# Wait for DB to be ready
db-wait:
	@echo "==> Waiting for Postgres to be ready..."
	@for i in $$(seq 1 30); do \
		if docker exec $(DB_CONTAINER) pg_isready -U $(DB_USER) -d $(DB_NAME) >/dev/null 2>&1; then \
        		echo "Postgres is ready ✅"; exit 0; \
      		fi; \
   			echo "  still starting... ($$i)"; sleep 2; \
    		done; \
	echo "Postgres did not start in time ❌" >&2; exit 1


# =========================
# 3) Run SQL Migrations
# =========================
migrate: db-start db-wait
	@if [ -f "$(SCHEMA_SQL)" ]; then \
		echo "==> Applying schema from $(SCHEMA_SQL)"; \
		docker run --rm --network $(DB_NETWORK) -v $$PWD:/work -w /work \
		postgres:15 bash -lc "PGPASSWORD=$(DB_PASSWORD) psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f $(SCHEMA_SQL)"; \
	else \
		echo "Schema file not found → skipping"; \
	fi

	@if [ -f "$(DML_SQL)" ]; then \
		echo "==> Applying DML from $(DML_SQL)"; \
		docker run --rm --network $(DB_NETWORK) -v $$PWD:/work -w /work \
			postgres:15 bash -lc "PGPASSWORD=$(DB_PASSWORD) psql -h $(DB_HOST) -U $(DB_USER) -d $(DB_NAME) -f $(DML_SQL)"; \
	else \
		echo "DML file not found → skipping"; \
	fi


# =========================
# 4) Run REST API
# =========================
api-run: build db-start db-wait
	@echo "==> Starting API container on port 5000"
	docker run --rm --name $(APP_NAME)_ctr \
       		 --network $(DB_NETWORK) \
       		 -p 5000:5000 \
        	 -e DATABASE_URL=$(DATABASE_URL) \
        	 $(APP_NAME):$(VERSION)

# =========================
# 5) One Command: DB + migrate + API
# =========================
up: db-start migrate api-run

down:
	- docker rm -f $(APP_NAME)_ctr >/dev/null 2>&1 || true
	- docker rm -f $(DB_CONTAINER) >/dev/null 2>&1 || true

# -----------------------------
# Help Menu
# -----------------------------
help:
	@echo "make build         - Build Docker image"
	@echo "make run           - Run app locally"
	@echo "make tag VERSION=x - Tag image using semver"
	@echo "make push          - Push to Docker Hub"
	@echo "make clean         - Remove local images"
